# 4일차

## 요약
- 웹 MVC를 개발하고 뷰를 개발함
- 클라이언트 측에서 GET, POST 요청할 때 처리할 Controller 구현
  - 사용자가 HTML Form으로 정보를 넘겼을 때 받는 방법
- H2 DB에 연결
- DB까지 통합하여 잘 작동하는지 통합테스트


## 회원 관리 예제 - 웹 MVC 개발
- 회원 웹 기능 - 홈 화면 추가
- 회원 웹 기능 - 등록
- 회원 웹 기능 - 조회

### 회원 웹 기능 - 홈 화면 추가
- `HomeController`: `/`를 GET했을 때 home.html을 리턴하도록
- 컨트롤러가 `static/`에 있는 `index.html`보다 우선순위가 높음

- 관련 소스
  - **HomeController.java**
  ```java
  @Controller
  public class HomeController {

      @GetMapping
      public String home() {
          return "home";
      }
  }
  ```
  - **home.html**


### 회원 웹 기능 - 등록

- 관련 소스
  - **MemberController**
    ```java
    @Controller
    public class MemberController {

        private final MemberService memberService;

        @Autowired  //생성될 때 스프링 빈에 등록되어 있는 MemberService 객체를 넣어준다.
        public MemberController(MemberService memberService) {
            this.memberService = memberService;
        }

        @GetMapping("/members/new")
        public String createForm() {
            return "members/createMemberForm";
        }

        @PostMapping("/members/new")
        public String create(MemberForm form) {
            Member member = new Member();
            member.setName(form.getName());

            memberService.join(member);
            return "redirect:/";
        }
    }
    ```
  - **MemberForm**
    ```java
    public class MemberForm {
        private String name;

        // ALT + Insert: 자동 메소드 생성
        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
    ```
  - **members/createMemberForm.html**

- 동작 과정
  - `/members/new`로 GET 요청
  - `MemberConroller`에 위 요청과 관련된 처리 함수가 있는지 찾음
  - 처리 함수가 `"members/createMemberForm"`을 반환하면 ViewResolver가 `members/createMemberForm.html`를 선택하여 반환
  - html의 Form을 통해 `/members/new`로 POST 요청을 하게 된다. 이 때 데이터도 함께 전달된다. (`name`)
  - 전달받은 데이터를 스프링이 알아서(??!) `MemberForm` 객체로 만들어준다. (setter를 이용해서 `name`필드에 값을 직접 넣어줌..)
    - 이게 자동으로 되다니
    - MemberForm은 그냥 일반적인 클래스인데 자동으로 되는 게 신기하다.

### 회원 웹 기능 - 조회

- 관련 소스
  - **MemberController.java** (내용 추가)
    ```java
    @GetMapping("/members")
    public String list(Model model) {
        List<Member> members = memberService.findMembers();
        model.addAttribute("members", members);
        return "members/memberList";
    }
    ```
  - **members/memberList.html**

- 동작 과정
  - `/members`로 GET 요청
  - `MemberController`에서 위 요청과 관련된 처리 함수가 있는지 찾음
  - 처리 함수가 적당한 처리를 한 뒤 `"members/memberList"`를 반환하면 ViewResolver가 `/members/memberList.html`을 선택하여 반환
    - 이 때 템플릿 엔진에 의해 html에 적당한 처리 과정이 들어감
    - `model`의 attribute로 넘겨줬던 `members` 리스트를 보고 리스트 형태로 html을 작성해준다.
    - 근데 Java의 List<>를 어떻게 템플릿 엔진에서 해석하는지는 모르겠음

- 단축키
  - Ctrl+E: 최근에 봤던 파일 보여줌


## 스프링 DB 접근 기술
- 서비스는 잘 구현되었으나 저장매체로 메인메모리를 사용해서 서비스를 껐다 키면 데이터가 초기화됨
- 그래서 이제 DB를 연결해보자

- 실습 순서
  1. H2 데이터베이스 설치
  2. 순수 Jdbc
  3. 스프링 통합 테스트
  4. 스프링 JdbcTemplate
  5. JPA
  6. 스프링 데이터 JPA


## 1. H2 데이터베이스 설치
- 본 실습에서는 간단한 데이터베이스인 H2 데이터베이스 이용
- H2 데이터베이스는 웹 콘솔 지원
  - 실행하면 `~`에 db 파일 생성됨
- 테이블 생성
    ```sql
    drop table if exists member CASCADE;
    create table member
    (
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
    );
    ```

## 2. 순수 Jdbc
- 애플리케이션에 DB를 연동해보자
- 가장 오래된 고대의 방식
  - 지금은 잘 안 쓴다.

- 자바가 DB랑 붙으려면 Jdbc 드라이버가 있어야한다.
- `build.gradle`의 dependencies에 아래의 내용 추가
    ```gradle
    implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    runtimeOnly 'com.h2database:h2'
    ```
- `application.properties`에 아래의 내용 추가
  ```properties
  spring.datasource.url=jdbc:h2:tcp://localhost/~/test
  spring.datasource.driver-class-name=org.h2.Driver
  spring.datasource.username=sa
  ```

- 여기까지 하면 H2 DB가 연결된다.

- 이제 `JdbcMemberRepository` 구현 클래스를 만들면 된다.
  - `DataSource` 클래스를 만들어서 DI 방식으로 구현해놓으면 스프링이 알아서 주입해준다.
  - `DataSource` 인스턴스에 `getConnection()` 메소드를 사용하면 실제 DB에 연결되는 소켓(?)을 얻을 수 있다.
  - `getConnection()` 메소드를 쓰는 이유는 스프링 컨테이너 전체에 Connection을 하나로 유지하기 위함 (싱글톤)

- 클래스를 다 구현했으면, `SpringConfig.java`를 수정해서 `JdbcMemberRepository`에 연결한다.
  ```java
  @Configuration
  public class SpringConfig {
  
      private DataSource dataSource;
  
      @Autowired
      public SpringConfig(DataSource dataSource) {
          this.dataSource = dataSource;
      }
  
      @Bean
      public MemberService memberService() {
          return new MemberService(memberRepository());
      }
  
      @Bean
      public MemberRepository memberRepository() {
  //        return new MemoryMemberRepository();
          return new JdbcMemberRepository(dataSource);
      }
  }
  ```
  - 자바 코드로 직접 빈으로 등록해놓으면 이럴 때 편함
    - 다른 소스코드 안 건들고 `SpringConfig.java`만 수정해서 새로운 DB 적용 가능! -> **다형성 활용**

- **개방-폐쇄 원칙 (OCP, Open-Closed Principle)**
  - 확장에는 열려있고, 수정에는 닫혀있다.
- 스프링의 DI를 사용하면 **기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경할 수 있다.**
- 너무 신기하다
  - Repository를 구현만 하면 간편히 연결해서 바로 사용 가능!

## 3. 스프링 통합 테스트
- 이제 DB까지 사용하니까 스프링 컨테이너와 DB까지 연결하는 **통합 테스트**를 진행한다.
- 저번 테스트는 순수 자바 코드로 했지만 이번엔 스프링의 기능을 이용


- 관련 소스
  - **MemberServiceIntegrationTest**
    ```java
    @SpringBootTest
    @Transactional
    class MemberServiceIntegrationTest {

        @Autowired MemberRepository repository;
        @Autowired MemberService memberService;

        @Test
        void 회원가입() {
            //given
            Member member = new Member();
            member.setName("MunikBot");

            //when
            Long saveId = memberService.join(member);

            //then
            Member findMember = memberService.findOne(saveId).get();
            assertThat(member.getName()).isEqualTo(findMember.getName());
        }

        @Test
        public void 중복_회원_예외() {
            //given
            Member member1 = new Member();
            member1.setName("MunikBot");

            Member member2 = new Member();
            member2.setName("MunikBot");

            //when
            memberService.join(member1);
            //예외 발생 검증
            IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));
            assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다."); // 메시지 검증
        }
    }
    ```

- `@SpringBootTest`: 스프링 컨테이너와 테스트를 함께 실행
- `@Transactional`: 테스트를 수행 후 DB의 상태를 테스트 이전으로 롤백
  - 트랜잭션을 먼저 시작하고(?) 나중에 취소시켜서 실제 DB에는 반영되지 않도록 함
  - 각 테스트 간 영향을 끼치지 않게 한다.


- 참고
  - 단위테스트(클래스)는 스프링 없이 순수 자바 코드로 테스트
  - 통합테스트는 스프링 컨테이너 상에 테스트