# JPQL 중급 문법

## 경로 표현식

점을 찍어 객체 그래프를 탐색

- 상태 필드
  - select m.username
  - 값을저장하기 위한 필드
  - 경로 탐색의 끝
- 단일 값 연관 필드
  - join m.team t 
  - ManyToOne, OneToOne과 같이 대상이 엔티티
  - 묵시적 내부 조인 발생
- 컬렉션 값 연관 필드
  - join m.orders o
  - OneToMany와 같이 대상이 컬렉션
  - 묵시적 내부 조인 발생
  - 탐색 불가능 -> 명시적 조인

묵시적 조인 -> 쿼리 튜닝하기 어려우니까 하지 말자



## 페치 조인

> 실무에서 정말 정말 중요함
>
> \- 김영한님

JPQL에서 성능 최적화를 위해 제공하는 기능

ManyToOne에서 N + 1 문제를 해결할 수 있다.

- 회원의 팀을 N번 조회해야할 때
- 페치 조인으로 회원과 팀을 함께 조회해서 지연로딩을 하지 않는다

### 컬렉션 페치 조인

OneToMany에서 사용

문제점

- 컬렉션 페치 조인을 하면 중복된 결과가 나옴(데이터 뻥튀기)
- -> JPQL의 DISTINCT를 사용
  - SQL에 DISTINCT 추가
  - 어플리케이션에서 엔티티 중복 제거

### 일반 조인과의 차이점

일반 조인은 연관된 엔티티를 함께 조회하지 않는다.

### 페치 조인의 한계

페치 조인 대상에는 별칭을 줄 수 없다.

둘 이상의 컬렉션은 페치 조인 할 수 없다.

일대다에서 페이징 API를 쓸 수 없다. -> batchsize로 해결



## 다형성 쿼리

TREAT: 상속 구조에서 부모타입을 특정 자식타입으로 다룰 때(다운 캐스팅)



## Named 쿼리

쿼리의 이름을 지정해서 재활용 할 수 있다.

어노테이션 또는 XML에 정의

정적 쿼리

- 애플리케이션 로딩 시점에 초기화 후 재사용(캐싱 된다)
- 애플리케이션 로딩 시점에 쿼리를 검증

spring data jpa에서 @Query가 Named 쿼리임



## 벌크 연산

쿼리 한번으로 여러 로우 변경(예를 들어 모든 물품 가격이 10% 상승, 재고가 10개 미만인 상품 리스트로 조회)

excuteUpdate()

벌크 연산은 영속성 컨텍스트를 무시하고 직접 DB에 쿼리

- 벌크 연산을 가장 먼저 수행하거나
- 또는 벌크 연산 수행 수 영속성 컨텍스트 초기화 해버려야한다. (꼭 em.clear())
- spring data jpa에서는 @Modifying을 넣으면 알아서 자동으로 clear 해준다.

